<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Font Curator — Intelligent Font Deduplication</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Instrument+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #141414;
      --bg-tertiary: #1a1a1a;
      --bg-elevated: #222;
      --text-primary: #f5f5f5;
      --text-secondary: #888;
      --text-muted: #555;
      --accent: #e8ff47;
      --accent-dim: #b8cc39;
      --border: #2a2a2a;
      --success: #4ade80;
      --error: #f87171;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Instrument Sans', -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 3rem;
      padding-bottom: 2rem;
      border-bottom: 1px solid var(--border);
    }

    .logo {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .logo h1 {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: -0.03em;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .logo h1 span {
      color: var(--accent);
    }

    .logo p {
      font-family: 'DM Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .stats-bar {
      display: flex;
      gap: 2rem;
      font-family: 'DM Mono', monospace;
      font-size: 0.85rem;
    }

    .stat {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 500;
      color: var(--text-primary);
      font-family: 'Instrument Sans', sans-serif;
    }

    .stat-label {
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.7rem;
    }

    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: 1rem;
      padding: 4rem 2rem;
      text-align: center;
      background: var(--bg-secondary);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .drop-zone::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 40%, rgba(232, 255, 71, 0.03) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .drop-zone:hover,
    .drop-zone.drag-over {
      border-color: var(--accent);
      background: var(--bg-tertiary);
    }

    .drop-zone:hover::before,
    .drop-zone.drag-over::before {
      opacity: 1;
    }

    .drop-zone-icon {
      width: 80px;
      height: 80px;
      margin: 0 auto 1.5rem;
      border: 2px solid var(--border);
      border-radius: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
    }

    .drop-zone-icon svg {
      width: 40px;
      height: 40px;
      stroke: var(--text-secondary);
      transition: stroke 0.3s ease;
    }

    .drop-zone:hover .drop-zone-icon svg {
      stroke: var(--accent);
    }

    .drop-zone h2 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .drop-zone p {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .drop-zone input {
      display: none;
    }

    .processing-section {
      display: none;
      margin-top: 2rem;
    }

    .processing-section.active {
      display: block;
    }

    .progress-container {
      background: var(--bg-secondary);
      border-radius: 1rem;
      padding: 2rem;
      border: 1px solid var(--border);
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .progress-title {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .progress-title h3 {
      font-size: 1rem;
      font-weight: 600;
    }

    .progress-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .progress-percentage {
      font-family: 'DM Mono', monospace;
      font-size: 1.5rem;
      color: var(--accent);
    }

    .progress-bar-container {
      height: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-dim), var(--accent));
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }

    .progress-status {
      font-family: 'DM Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .results-section {
      display: none;
      margin-top: 2rem;
    }

    .results-section.active {
      display: block;
    }

    .results-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    @media (max-width: 900px) {
      .results-grid {
        grid-template-columns: 1fr;
      }
    }

    .result-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
      transition: all 0.3s ease;
    }

    .result-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .result-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
    }

    .result-card-title {
      font-family: 'DM Mono', monospace;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }

    .result-card-count {
      font-size: 2.5rem;
      font-weight: 700;
      line-height: 1;
    }

    .result-card-badge {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.35rem 0.75rem;
      font-family: 'DM Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .font-preview-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 1.5rem;
      padding-right: 0.5rem;
    }

    .font-preview-list::-webkit-scrollbar {
      width: 4px;
    }

    .font-preview-list::-webkit-scrollbar-track {
      background: var(--bg-tertiary);
      border-radius: 2px;
    }

    .font-preview-list::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .font-preview-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-tertiary);
      border-radius: 0.5rem;
      font-size: 0.8rem;
    }

    .font-preview-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      flex-shrink: 0;
    }

    .font-preview-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-secondary);
    }

    .download-btn {
      width: 100%;
      padding: 1rem;
      background: var(--accent);
      border: none;
      border-radius: 0.75rem;
      font-family: 'Instrument Sans', sans-serif;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--bg-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.2s ease;
    }

    .download-btn:hover {
      background: var(--accent-dim);
      transform: scale(1.02);
    }

    .download-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .download-btn svg {
      width: 18px;
      height: 18px;
    }

    .removed-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
    }

    .removed-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      cursor: pointer;
    }

    .removed-header h3 {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .removed-count {
      font-family: 'DM Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .removed-list {
      display: none;
      flex-wrap: wrap;
      gap: 0.5rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .removed-list.expanded {
      display: flex;
    }

    .removed-item {
      padding: 0.35rem 0.75rem;
      background: var(--bg-tertiary);
      border-radius: 0.35rem;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .reset-btn {
      margin-top: 2rem;
      padding: 0.75rem 1.5rem;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      font-family: 'Instrument Sans', sans-serif;
      font-size: 0.85rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .reset-btn:hover {
      border-color: var(--text-secondary);
      color: var(--text-primary);
    }

    .toast {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1rem 1.5rem;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    .toast.success {
      border-color: var(--success);
    }

    .toast.error {
      border-color: var(--error);
    }

    footer {
      margin-top: 4rem;
      padding-top: 2rem;
      border-top: 1px solid var(--border);
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    footer a {
      color: var(--text-secondary);
      text-decoration: none;
    }

    footer a:hover {
      color: var(--accent);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <h1>Font <span>Curator</span></h1>
        <p>Intelligent font deduplication system</p>
      </div>
      <div class="stats-bar">
        <div class="stat">
          <span class="stat-value" id="totalFonts">0</span>
          <span class="stat-label">Loaded</span>
        </div>
        <div class="stat">
          <span class="stat-value" id="uniqueFonts">0</span>
          <span class="stat-label">Unique</span>
        </div>
        <div class="stat">
          <span class="stat-value" id="removedFonts">0</span>
          <span class="stat-label">Removed</span>
        </div>
      </div>
    </header>

    <main>
      <div class="drop-zone" id="dropZone">
        <div class="drop-zone-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="1.5">
            <path d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <h2>Drop your font folder here</h2>
        <p>Or click to select — supports .ttf, .otf, and .woff files</p>
        <input type="file" id="fileInput" webkitdirectory directory multiple accept=".ttf,.otf,.woff,.woff2">
      </div>

      <section class="processing-section" id="processingSection">
        <div class="progress-container">
          <div class="progress-header">
            <div class="progress-title">
              <div class="progress-spinner"></div>
              <h3 id="progressTitle">Loading fonts...</h3>
            </div>
            <span class="progress-percentage" id="progressPercentage">0%</span>
          </div>
          <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar"></div>
          </div>
          <p class="progress-status" id="progressStatus">Initializing...</p>
        </div>
      </section>

      <section class="results-section" id="resultsSection">
        <div class="results-grid">
          <div class="result-card">
            <div class="result-card-header">
              <div>
                <p class="result-card-title">Pack A</p>
                <p class="result-card-count" id="packACount">200</p>
              </div>
              <span class="result-card-badge">Display & Decorative</span>
            </div>
            <div class="font-preview-list" id="packAList"></div>
            <button class="download-btn" id="downloadA">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
              </svg>
              Download Pack A
            </button>
          </div>

          <div class="result-card">
            <div class="result-card-header">
              <div>
                <p class="result-card-title">Pack B</p>
                <p class="result-card-count" id="packBCount">200</p>
              </div>
              <span class="result-card-badge">Sans-Serif & Modern</span>
            </div>
            <div class="font-preview-list" id="packBList"></div>
            <button class="download-btn" id="downloadB">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
              </svg>
              Download Pack B
            </button>
          </div>

          <div class="result-card">
            <div class="result-card-header">
              <div>
                <p class="result-card-title">Pack C</p>
                <p class="result-card-count" id="packCCount">200</p>
              </div>
              <span class="result-card-badge">Serif & Script</span>
            </div>
            <div class="font-preview-list" id="packCList"></div>
            <button class="download-btn" id="downloadC">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
              </svg>
              Download Pack C
            </button>
          </div>
        </div>

        <div class="removed-section">
          <div class="removed-header" id="removedHeader">
            <h3>Similar fonts removed</h3>
            <span class="removed-count" id="removedCountLabel">0 fonts</span>
          </div>
          <div class="removed-list" id="removedList"></div>
        </div>

        <button class="reset-btn" id="resetBtn">Start over with new fonts</button>
      </section>
    </main>

    <footer>
      <p>Font Curator — Built for designers who value variety</p>
    </footer>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const processingSection = document.getElementById('processingSection');
    const resultsSection = document.getElementById('resultsSection');
    const progressBar = document.getElementById('progressBar');
    const progressPercentage = document.getElementById('progressPercentage');
    const progressStatus = document.getElementById('progressStatus');
    const progressTitle = document.getElementById('progressTitle');
    const toast = document.getElementById('toast');

    let fontData = [];
    let uniqueFonts = [];
    let removedFonts = [];
    let packs = { a: [], b: [], c: [] };

    // Drag and drop handlers
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('drag-over');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('drag-over');
    });

    dropZone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
      
      const items = e.dataTransfer.items;
      const files = [];
      
      for (const item of items) {
        if (item.kind === 'file') {
          const entry = item.webkitGetAsEntry();
          if (entry) {
            await traverseFileTree(entry, files);
          }
        }
      }
      
      if (files.length > 0) {
        processFiles(files);
      }
    });

    dropZone.addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files).filter(f => 
        /\.(ttf|otf|woff|woff2)$/i.test(f.name)
      );
      if (files.length > 0) {
        processFiles(files);
      }
    });

    async function traverseFileTree(entry, files) {
      if (entry.isFile) {
        const file = await new Promise(resolve => entry.file(resolve));
        if (/\.(ttf|otf|woff|woff2)$/i.test(file.name)) {
          files.push(file);
        }
      } else if (entry.isDirectory) {
        const reader = entry.createReader();
        const entries = await new Promise(resolve => reader.readEntries(resolve));
        for (const e of entries) {
          await traverseFileTree(e, files);
        }
      }
    }

    async function processFiles(files) {
      fontData = [];
      uniqueFonts = [];
      removedFonts = [];
      
      dropZone.style.display = 'none';
      processingSection.classList.add('active');
      resultsSection.classList.remove('active');
      
      updateProgress(0, 'Loading fonts...', 'Reading font files');
      
      // Load and parse fonts
      const totalFiles = files.length;
      let loaded = 0;
      
      for (const file of files) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          const font = opentype.parse(arrayBuffer);
          
          if (font) {
            const metrics = extractFontMetrics(font, file.name);
            fontData.push({
              file: file,
              name: font.names.fullName?.en || file.name.replace(/\.[^.]+$/, ''),
              family: font.names.fontFamily?.en || 'Unknown',
              metrics: metrics,
              arrayBuffer: arrayBuffer
            });
          }
        } catch (e) {
          console.warn(`Could not parse ${file.name}:`, e);
        }
        
        loaded++;
        const progress = Math.round((loaded / totalFiles) * 40);
        updateProgress(progress, 'Loading fonts...', `Parsed ${loaded} of ${totalFiles} fonts`);
      }
      
      document.getElementById('totalFonts').textContent = fontData.length;
      
      if (fontData.length < 600) {
        showToast(`Only ${fontData.length} fonts loaded. Need at least 600 for full packs.`, 'error');
      }
      
      // Analyze similarities
      updateProgress(45, 'Analyzing similarities...', 'Comparing font characteristics');
      await new Promise(r => setTimeout(r, 100));
      
      uniqueFonts = deduplicateFonts(fontData);
      removedFonts = fontData.filter(f => !uniqueFonts.includes(f));
      
      document.getElementById('uniqueFonts').textContent = uniqueFonts.length;
      document.getElementById('removedFonts').textContent = removedFonts.length;
      
      // Distribute into packs
      updateProgress(80, 'Creating packs...', 'Distributing fonts into categories');
      await new Promise(r => setTimeout(r, 100));
      
      distributeFonts();
      
      updateProgress(100, 'Complete!', `${uniqueFonts.length} unique fonts organized`);
      
      setTimeout(() => {
        processingSection.classList.remove('active');
        resultsSection.classList.add('active');
        renderResults();
      }, 500);
    }

    function extractFontMetrics(font, filename) {
      const os2 = font.tables.os2 || {};
      const head = font.tables.head || {};
      const post = font.tables.post || {};
      
      // Get various metrics for comparison
      const unitsPerEm = head.unitsPerEm || 1000;
      
      // Weight class (100-900)
      const weightClass = os2.usWeightClass || 400;
      
      // Width class (1-9)
      const widthClass = os2.usWidthClass || 5;
      
      // Calculate x-height ratio
      const xHeight = os2.sxHeight || (unitsPerEm * 0.5);
      const xHeightRatio = xHeight / unitsPerEm;
      
      // Cap height ratio
      const capHeight = os2.sCapHeight || (unitsPerEm * 0.7);
      const capHeightRatio = capHeight / unitsPerEm;
      
      // Ascender/descender
      const ascender = os2.sTypoAscender || font.ascender || unitsPerEm;
      const descender = Math.abs(os2.sTypoDescender || font.descender || 0);
      
      // Panose classification for style
      const panose = os2.panose || [0,0,0,0,0,0,0,0,0,0];
      
      // Check for italic
      const isItalic = (head.macStyle & 2) !== 0 || post.italicAngle !== 0;
      
      // Serif vs sans detection from panose
      const serifStyle = panose[1]; // 2-10 = serif variants, 11-15 = sans
      const isSerif = serifStyle >= 2 && serifStyle <= 10;
      const isSans = serifStyle >= 11 && serifStyle <= 15;
      const isScript = panose[0] === 3;
      const isDecorative = panose[0] === 4;
      
      // Get average character width by sampling
      let avgWidth = 0.5;
      try {
        const testChars = 'abcdefghijklmnopqrstuvwxyz';
        let totalWidth = 0;
        let count = 0;
        for (const char of testChars) {
          const glyph = font.charToGlyph(char);
          if (glyph && glyph.advanceWidth) {
            totalWidth += glyph.advanceWidth;
            count++;
          }
        }
        if (count > 0) {
          avgWidth = (totalWidth / count) / unitsPerEm;
        }
      } catch (e) {}
      
      return {
        weightClass,
        widthClass,
        xHeightRatio,
        capHeightRatio,
        ascender: ascender / unitsPerEm,
        descender: descender / unitsPerEm,
        avgWidth,
        isItalic,
        isSerif,
        isSans,
        isScript,
        isDecorative,
        panose
      };
    }

    function calculateSimilarity(a, b) {
      // Weight difference (0-800 range, normalize to 0-1)
      const weightDiff = Math.abs(a.weightClass - b.weightClass) / 800;
      
      // Width difference (1-9 range)
      const widthDiff = Math.abs(a.widthClass - b.widthClass) / 8;
      
      // x-height difference
      const xHeightDiff = Math.abs(a.xHeightRatio - b.xHeightRatio);
      
      // Cap height difference
      const capHeightDiff = Math.abs(a.capHeightRatio - b.capHeightRatio);
      
      // Average width difference
      const avgWidthDiff = Math.abs(a.avgWidth - b.avgWidth);
      
      // Style penalties
      let stylePenalty = 0;
      if (a.isItalic !== b.isItalic) stylePenalty += 0.3;
      if (a.isSerif !== b.isSerif) stylePenalty += 0.4;
      if (a.isSans !== b.isSans) stylePenalty += 0.4;
      if (a.isScript !== b.isScript) stylePenalty += 0.5;
      if (a.isDecorative !== b.isDecorative) stylePenalty += 0.5;
      
      // Weighted similarity score (lower = more similar)
      const similarity = (
        weightDiff * 0.25 +
        widthDiff * 0.15 +
        xHeightDiff * 0.2 +
        capHeightDiff * 0.1 +
        avgWidthDiff * 0.15 +
        stylePenalty * 0.15
      );
      
      return similarity;
    }

    function deduplicateFonts(fonts) {
      if (fonts.length <= 600) {
        return [...fonts];
      }
      
      // Sort by name to prioritize keeping well-named fonts
      const sorted = [...fonts].sort((a, b) => {
        // Prefer fonts with proper family names
        const aScore = a.family !== 'Unknown' ? 1 : 0;
        const bScore = b.family !== 'Unknown' ? 1 : 0;
        return bScore - aScore;
      });
      
      const kept = [];
      const similarityThreshold = 0.08; // Adjust this to be more/less aggressive
      
      for (const font of sorted) {
        // Check if this font is too similar to any kept font
        let tooSimilar = false;
        
        for (const keptFont of kept) {
          const similarity = calculateSimilarity(font.metrics, keptFont.metrics);
          if (similarity < similarityThreshold) {
            // Also check if names are similar (same family)
            if (font.family === keptFont.family || 
                font.name.toLowerCase().includes(keptFont.name.toLowerCase().split(' ')[0])) {
              tooSimilar = true;
              break;
            }
            // For very similar metrics, remove regardless of name
            if (similarity < 0.03) {
              tooSimilar = true;
              break;
            }
          }
        }
        
        if (!tooSimilar) {
          kept.push(font);
        }
        
        // Stop if we have enough
        if (kept.length >= 600) {
          break;
        }
      }
      
      // If we still have too many, increase threshold and retry
      if (kept.length > 600) {
        return kept.slice(0, 600);
      }
      
      // If we don't have enough, add back some removed fonts
      if (kept.length < 600) {
        for (const font of sorted) {
          if (!kept.includes(font)) {
            kept.push(font);
            if (kept.length >= 600) break;
          }
        }
      }
      
      return kept;
    }

    function distributeFonts() {
      // Categorize fonts
      const decorative = [];
      const sans = [];
      const serifAndScript = [];
      const other = [];
      
      for (const font of uniqueFonts) {
        const m = font.metrics;
        if (m.isDecorative || m.isScript) {
          serifAndScript.push(font);
        } else if (m.isSerif) {
          serifAndScript.push(font);
        } else if (m.isSans) {
          sans.push(font);
        } else {
          // Classify based on weight - heavier fonts to decorative, lighter to sans
          if (m.weightClass >= 600) {
            decorative.push(font);
          } else {
            other.push(font);
          }
        }
      }
      
      // Add decorative and other to fill categories
      decorative.push(...other.filter((_, i) => i % 2 === 0));
      sans.push(...other.filter((_, i) => i % 2 === 1));
      
      // Shuffle each category
      shuffle(decorative);
      shuffle(sans);
      shuffle(serifAndScript);
      
      // Distribute evenly
      const target = Math.min(200, Math.floor(uniqueFonts.length / 3));
      
      packs.a = decorative.slice(0, target);
      packs.b = sans.slice(0, target);
      packs.c = serifAndScript.slice(0, target);
      
      // Fill remaining slots
      const allRemaining = [
        ...decorative.slice(target),
        ...sans.slice(target),
        ...serifAndScript.slice(target)
      ];
      shuffle(allRemaining);
      
      let idx = 0;
      while (packs.a.length < target && idx < allRemaining.length) {
        packs.a.push(allRemaining[idx++]);
      }
      while (packs.b.length < target && idx < allRemaining.length) {
        packs.b.push(allRemaining[idx++]);
      }
      while (packs.c.length < target && idx < allRemaining.length) {
        packs.c.push(allRemaining[idx++]);
      }
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function renderResults() {
      const renderList = (pack, listId, countId) => {
        const list = document.getElementById(listId);
        const count = document.getElementById(countId);
        
        count.textContent = pack.length;
        list.innerHTML = pack.slice(0, 50).map(font => `
          <div class="font-preview-item">
            <span class="font-preview-dot"></span>
            <span class="font-preview-name">${font.name}</span>
          </div>
        `).join('');
        
        if (pack.length > 50) {
          list.innerHTML += `
            <div class="font-preview-item">
              <span class="font-preview-name" style="color: var(--text-muted)">+ ${pack.length - 50} more...</span>
            </div>
          `;
        }
      };
      
      renderList(packs.a, 'packAList', 'packACount');
      renderList(packs.b, 'packBList', 'packBCount');
      renderList(packs.c, 'packCList', 'packCCount');
      
      // Render removed fonts
      const removedList = document.getElementById('removedList');
      const removedCountLabel = document.getElementById('removedCountLabel');
      removedCountLabel.textContent = `${removedFonts.length} fonts`;
      
      removedList.innerHTML = removedFonts.slice(0, 100).map(font => `
        <span class="removed-item">${font.name}</span>
      `).join('');
      
      if (removedFonts.length > 100) {
        removedList.innerHTML += `<span class="removed-item">+ ${removedFonts.length - 100} more</span>`;
      }
    }

    // Toggle removed fonts list
    document.getElementById('removedHeader').addEventListener('click', () => {
      document.getElementById('removedList').classList.toggle('expanded');
    });

    // Download handlers
    async function downloadPack(pack, name) {
      const btn = document.getElementById(`download${name.toUpperCase()}`);
      btn.disabled = true;
      btn.innerHTML = `
        <div class="progress-spinner" style="width:18px;height:18px;border-width:2px;border-color:var(--bg-primary);border-top-color:var(--accent)"></div>
        Creating ZIP...
      `;
      
      try {
        const zip = new JSZip();
        
        for (const font of pack) {
          const ext = font.file.name.split('.').pop();
          const safeName = font.name.replace(/[<>:"/\\|?*]/g, '_');
          zip.file(`${safeName}.${ext}`, font.arrayBuffer);
        }
        
        const blob = await zip.generateAsync({ 
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `font-curator-pack-${name.toLowerCase()}.zip`;
        a.click();
        URL.revokeObjectURL(url);
        
        showToast(`Pack ${name} downloaded successfully!`, 'success');
      } catch (e) {
        console.error(e);
        showToast('Failed to create ZIP file', 'error');
      }
      
      btn.disabled = false;
      btn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
        </svg>
        Download Pack ${name}
      `;
    }

    document.getElementById('downloadA').addEventListener('click', () => downloadPack(packs.a, 'A'));
    document.getElementById('downloadB').addEventListener('click', () => downloadPack(packs.b, 'B'));
    document.getElementById('downloadC').addEventListener('click', () => downloadPack(packs.c, 'C'));

    // Reset
    document.getElementById('resetBtn').addEventListener('click', () => {
      fontData = [];
      uniqueFonts = [];
      removedFonts = [];
      packs = { a: [], b: [], c: [] };
      
      dropZone.style.display = 'block';
      processingSection.classList.remove('active');
      resultsSection.classList.remove('active');
      
      document.getElementById('totalFonts').textContent = '0';
      document.getElementById('uniqueFonts').textContent = '0';
      document.getElementById('removedFonts').textContent = '0';
      
      fileInput.value = '';
    });

    function updateProgress(percent, title, status) {
      progressBar.style.width = `${percent}%`;
      progressPercentage.textContent = `${percent}%`;
      progressTitle.textContent = title;
      progressStatus.textContent = status;
    }

    function showToast(message, type = 'success') {
      toast.textContent = message;
      toast.className = `toast ${type} show`;
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }
  </script>
</body>
</html>
