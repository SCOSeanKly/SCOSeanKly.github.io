
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walls Uploader</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --text-color: #1f2937;
            --bg-color: #f3f4f6;
            --card-bg: #ffffff;
            --border-color: #d1d5db;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
        }
        
        h1 {
            color: var(--primary-color);
            margin-top: 0;
            font-weight: 600;
            font-size: 28px;
            margin-bottom: 24px;
            text-align: center;
        }
        
        h3 {
            color: var(--primary-color);
            margin-top: 0;
            font-weight: 500;
        }
        
        .form-group {
            margin-bottom: 24px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 16px;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }
        
        input[type="file"] {
            padding: 8px;
            background-color: #f9fafb;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            width: 100%;
            transition: all 0.2s;
        }
        
        button:hover:not(:disabled) {
            background-color: #1d4ed8;
            transform: translateY(-1px);
        }
        
        button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        
        .button-secondary {
            background-color: #6b7280;
            margin-top: 10px;
        }
        
        .button-secondary:hover:not(:disabled) {
            background-color: #4b5563;
        }
        
        .preview {
            margin-top: 30px;
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            background-color: #f9fafb;
        }
        
        #imagePreview {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
        }
        
        .thumbnail-container {
            position: relative;
            margin-bottom: 5px;
        }
        
        .thumbnail {
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: transform 0.2s;
        }
        
        .thumbnail:hover {
            transform: scale(1.05);
        }
        
        .filename-preview {
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
            text-align: center;
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }
        
        .progress-container {
            margin-top: 30px;
            display: none;
        }
        
        .progress-bar {
            height: 10px;
            border-radius: 5px;
            background-color: #e5e7eb;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status {
            margin-top: 12px;
            font-style: italic;
            color: #4b5563;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            border-radius: 50%;
        }
        
        .status-icon.pending {
            border: 2px solid var(--primary-color);
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        
        .status-icon.success {
            background-color: var(--success-color);
        }
        
        .status-icon.error {
            background-color: var(--error-color);
        }
        
        .file-info {
            margin-top: 10px;
            padding: 12px;
            background-color: #f0f9ff;
            border-radius: 8px;
            font-size: 14px;
            border-left: 4px solid var(--primary-color);
        }
        
        .file-info p {
            margin: 5px 0;
        }
        
        .last-files {
            margin-top: 20px;
            padding: 12px;
            background-color: #f0fff4;
            border-radius: 8px;
            font-size: 14px;
            border-left: 4px solid var(--success-color);
        }
        
        .last-files-title {
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .last-files-title button {
            width: auto;
            padding: 4px 8px;
            font-size: 12px;
            background-color: var(--warning-color);
        }
        
        .last-files-title button:hover {
            background-color: #d97706;
        }
        
        .last-file-item {
            padding: 4px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .last-file-item:last-child {
            border-bottom: none;
        }
        
        .loading-indicator {
            text-align: center;
            padding: 10px;
            color: var(--primary-color);
        }
        
        .refresh-icon {
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .refresh-icon:hover {
            background-color: #e2e8f0;
        }
        
        .refresh-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--primary-color);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: middle;
            margin-right: 5px;
        }
        
        .toggle-input {
            cursor: pointer;
            margin-right: 6px;
        }
        
        .advanced-options {
            margin-top: 10px;
            padding: 12px;
            background-color: #f9fafb;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        /* Gallery Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow: auto;
        }
        
        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto;
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: var(--error-color);
        }
        
        .gallery-title {
            margin-top: 0;
            color: var(--primary-color);
        }
        
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .gallery-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        
        .gallery-item.selected {
            border: 2px solid var(--primary-color);
        }
        
        .gallery-img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            display: block;
        }
        
        .gallery-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            z-index: 2;
        }
        
        .gallery-filename {
            padding: 8px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .gallery-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .gallery-count {
            font-size: 14px;
            color: var(--text-color);
            align-self: center;
        }
        
        .delete-selected-btn {
            background-color: var(--error-color);
        }
        
        .delete-selected-btn:hover:not(:disabled) {
            background-color: #dc2626;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            button {
                padding: 12px 16px;
            }
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
            .gallery-img {
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Walls Image Uploader</h1>
        
        <div class="form-group">
            <label for="githubToken">GitHub Token:</label>
            <input type="password" id="githubToken" placeholder="Enter your GitHub personal access token">
        </div>
        
        <div class="form-group">
            <label for="repo">GitHub Repository:</label>
            <input type="text" id="repo" value="SCOSeanKly/SCOSeanKly_walls_resources" placeholder="username/repository-name">
            <p style="font-size: 12px; margin-top: 4px; color: #6b7280;">Example: SCOSeanKly/USERNAME_Walls_Resources</p>
        </div>
        
        <div class="form-group">
            <input type="checkbox" id="useAdvancedOptions" class="toggle-input">
            <label for="useAdvancedOptions" style="display: inline-block;">Advanced Options</label>
            
            <div id="advancedOptions" class="advanced-options" style="display: none;">
                <div class="form-group" style="margin-bottom: 12px;">
                    <label for="uploadPath">Upload Path:</label>
                    <input type="text" id="uploadPath" value="Wallpapers" placeholder="Folder path in repository">
                    <p style="font-size: 12px; margin-top: 4px; color: #6b7280;">Leave blank to upload to root directory</p>
                </div>
                
                <div class="form-group" style="margin-bottom: 0;">
                    <label for="createFolderIfMissing">
                        <input type="checkbox" id="createFolderIfMissing" checked>
                        Create folder if it doesn't exist
                    </label>
                </div>
            </div>
        </div>
        
        <div class="last-files" id="lastFiles">
            <div class="last-files-title">
                <span>Recent Uploads</span>
                <button id="checkLastFiles">Fetch Latest Files</button>
            </div>
            <div id="lastFilesContent">
                <p>Click "Fetch Latest Files" to check recently uploaded files and automatically set the next number.</p>
            </div>
        </div>
        
        <div class="form-group">
            <label for="fileNamePrefix">File Name Prefix:</label>
            <input type="text" id="fileNamePrefix" value="WDG" placeholder="Prefix for file names">
        </div>
        
        <div class="form-group">
            <label for="startNumber">Start Number:</label>
            <input type="number" id="startNumber" value="1" min="1">
        </div>
        
        <div class="file-info">
            <p><strong>Each uploaded image will create:</strong></p>
            <p>1. Full resolution PNG: <span id="pngFilename">WDG1_fullRes.png</span></p>
            <p>2. Low resolution JPG (660×1431, quality: 6): <span id="jpgFilename">WDG1.jpg</span></p>
        </div>
        
        <div class="form-group">
            <label for="imageUpload">Select Images:</label>
            <input type="file" id="imageUpload" multiple accept="image/*">
        </div>
        
        <div class="preview">
            <h3>Preview</h3>
            <div id="imagePreview"></div>
        </div>
        
        <button id="uploadBtn" disabled>Upload to GitHub</button>
        <button id="viewGalleryBtn" class="button-secondary">View Gallery / Delete Images</button>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="status" id="statusContainer">
                <span class="status-icon pending" id="statusIcon"></span>
                <span id="statusText">Preparing upload...</span>
            </div>
            <div id="uploadDetails"></div>
        </div>
    </div>

    <!-- Gallery Modal -->
    <div id="galleryModal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h3 class="gallery-title">Repository Gallery</h3>
            <div id="galleryLoading" class="loading-indicator">
                <span class="refresh-spinner"></span> Loading images...
            </div>
            <div id="galleryContent" style="display: none;">
                <div class="gallery-grid" id="galleryGrid"></div>
                <div class="gallery-actions">
                    <div class="gallery-count" id="selectedCount">0 images selected</div>
                    <button id="deleteSelectedBtn" class="delete-selected-btn" disabled>Delete Selected</button>
                </div>
            </div>
        </div>
    </div>

    <script>

     // Basic DOM elements
const githubToken = document.getElementById('githubToken');
const repo = document.getElementById('repo');
const fileNamePrefix = document.getElementById('fileNamePrefix');
const startNumber = document.getElementById('startNumber');
const imageUpload = document.getElementById('imageUpload');
const pngFilename = document.getElementById('pngFilename');
const jpgFilename = document.getElementById('jpgFilename');
const imagePreview = document.getElementById('imagePreview');
const uploadBtn = document.getElementById('uploadBtn');
const progressContainer = document.getElementById('progressContainer');
const progressFill = document.getElementById('progressFill');
const statusIcon = document.getElementById('statusIcon');
const statusText = document.getElementById('statusText');
const uploadDetails = document.getElementById('uploadDetails');
const checkLastFilesBtn = document.getElementById('checkLastFiles');
const lastFilesContent = document.getElementById('lastFilesContent');
const useAdvancedOptions = document.getElementById('useAdvancedOptions');
const advancedOptions = document.getElementById('advancedOptions');
const uploadPath = document.getElementById('uploadPath');
const createFolderIfMissing = document.getElementById('createFolderIfMissing');
const viewGalleryBtn = document.getElementById('viewGalleryBtn');

// Gallery modal elements
const galleryModal = document.getElementById('galleryModal');
const closeModal = document.querySelector('.close-modal');
const galleryGrid = document.getElementById('galleryGrid');
const galleryLoading = document.getElementById('galleryLoading');
const galleryContent = document.getElementById('galleryContent');
const selectedCount = document.getElementById('selectedCount');
const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');

// Advanced options toggle
useAdvancedOptions.addEventListener('change', function() {
    advancedOptions.style.display = this.checked ? 'block' : 'none';
});

// Load saved settings from localStorage
if (localStorage.getItem('githubToken')) {
    githubToken.value = localStorage.getItem('githubToken');
}

if (localStorage.getItem('repo')) {
    repo.value = localStorage.getItem('repo');
}

if (localStorage.getItem('fileNamePrefix')) {
    fileNamePrefix.value = localStorage.getItem('fileNamePrefix');
}

if (localStorage.getItem('uploadPath')) {
    uploadPath.value = localStorage.getItem('uploadPath');
}

// Save token to localStorage
githubToken.addEventListener('change', function() {
    localStorage.setItem('githubToken', this.value);
});

// Save repo to localStorage
repo.addEventListener('change', function() {
    localStorage.setItem('repo', this.value);
});

// Save prefix to localStorage
fileNamePrefix.addEventListener('change', function() {
    localStorage.setItem('fileNamePrefix', this.value);
});

// Save upload path to localStorage
uploadPath.addEventListener('change', function() {
    localStorage.setItem('uploadPath', this.value);
});

// Simple preview update
function updateFilenamePreview() {
    const prefix = fileNamePrefix.value || 'WDG';
    const number = startNumber.value || 1;
    pngFilename.textContent = `${prefix}${number}_fullRes.png`;
    jpgFilename.textContent = `${prefix}${number}.jpg`;
}

// Add event listeners to update preview
fileNamePrefix.addEventListener('input', updateFilenamePreview);
startNumber.addEventListener('input', updateFilenamePreview);

// Initialize preview
updateFilenamePreview();

// Handle file selection
imageUpload.addEventListener('change', function(e) {
    // Clear preview area
    imagePreview.innerHTML = '';
    
    const files = this.files;
    
    // Enable or disable upload button based on file selection
    uploadBtn.disabled = files.length === 0;
    
    // Add upload info
    const uploadInfo = document.createElement('div');
    uploadInfo.className = 'upload-info';
    uploadInfo.textContent = `Selected ${files.length} image${files.length !== 1 ? 's' : ''}`;
    imagePreview.appendChild(uploadInfo);
    
    // Process each selected file (up to 50)
    for (let i = 0; i < Math.min(files.length, 100); i++) {
        const file = files[i];
        
        // Skip non-image files
        if (!file.type.match('image.*')) continue;
        
        // Create file preview
        const reader = new FileReader();
        
        // Calculate the filename that will be used
        const prefix = fileNamePrefix.value || 'WDG';
        const startIdx = parseInt(startNumber.value) || 1;
        const currentNumber = startIdx + i;
        
        // When file is loaded
        reader.onload = function(e) {
            // Create container
            const container = document.createElement('div');
            container.className = 'thumbnail-container';
            
            // Create thumbnail
            const img = document.createElement('img');
            img.src = e.target.result;
            img.className = 'thumbnail';
            img.title = file.name;
            container.appendChild(img);
            
            // Create filename preview
            const filenameDiv = document.createElement('div');
            filenameDiv.className = 'filename-preview';
            filenameDiv.textContent = `${prefix}${currentNumber}`;
            container.appendChild(filenameDiv);
            
            // Add to preview area
            imagePreview.appendChild(container);
        };
        
        // Read file
        reader.readAsDataURL(file);
    }
});

// Helper function to update status
function updateStatus(message, type, progressPercent) {
    statusText.textContent = message;
    statusIcon.className = `status-icon ${type}`;
    progressFill.style.width = `${progressPercent}%`;
}

// Helper function to add upload detail
function addUploadDetail(message) {
    const detail = document.createElement('div');
    detail.style.margin = '10px 0';
    detail.style.fontSize = '14px';
    detail.textContent = message;
    uploadDetails.appendChild(detail);
}

// Convert any image to PNG
function convertToPng(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
            img.src = e.target.result;
        };
        
        img.onload = () => {
            // Create canvas with original dimensions
            const canvas = document.createElement('canvas');
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext('2d');
            
            // Draw image at original size
            ctx.drawImage(img, 0, 0);
            
            // Convert to PNG
            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/png', 1.0);
        };
        
        img.onerror = () => {
            reject(new Error('Failed to load image'));
        };
        
        reader.readAsDataURL(file);
    });
}

// Create low resolution JPEG while preserving aspect ratio
function createLowResJpeg(file, targetWidth, targetHeight, quality) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = (e) => {
            img.src = e.target.result;
        };
        
        img.onload = () => {
            // Calculate aspect ratio
            const originalWidth = img.naturalWidth;
            const originalHeight = img.naturalHeight;
            const originalAspectRatio = originalWidth / originalHeight;
            
            // Determine new dimensions while preserving aspect ratio
            let newWidth, newHeight;
            const targetAspectRatio = targetWidth / targetHeight;
            
            if (originalAspectRatio > targetAspectRatio) {
                // Image is wider than target, constrain by width
                newWidth = targetWidth;
                newHeight = newWidth / originalAspectRatio;
            } else {
                // Image is taller than target, constrain by height
                newHeight = targetHeight;
                newWidth = newHeight * originalAspectRatio;
            }
            
            // Create canvas for resizing
            const canvas = document.createElement('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;
            const ctx = canvas.getContext('2d');
            
            // Draw image with new dimensions
            ctx.drawImage(img, 0, 0, newWidth, newHeight);
            
            // Convert to JPEG with specified quality
            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/jpeg', quality);
        };
        
        img.onerror = () => {
            reject(new Error('Failed to load image'));
        };
        
        reader.readAsDataURL(file);
    });
}

// Convert blob to base64
function readBlobAsBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            const base64Data = reader.result.split(',')[1];
            resolve(base64Data);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// Get repository content - fixed implementation that uses the Git Tree API
async function getRepositoryContent(owner, repo, token, path = '') {
    try {
        // First get the default branch
        const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (!repoResponse.ok) {
            if (repoResponse.status === 404) {
                throw new Error(`Repository "${owner}/${repo}" not found. Please check the repository name.`);
            } else if (repoResponse.status === 401) {
                throw new Error(`Authentication failed. Please check your GitHub token.`);
            } else {
                const errorData = await repoResponse.json().catch(() => ({}));
                throw new Error(`GitHub API error (${repoResponse.status}): ${errorData.message || repoResponse.statusText}`);
            }
        }
        
        const repoInfo = await repoResponse.json();
        const defaultBranch = repoInfo.default_branch;
        
        // Get the complete tree with recursive option to include ALL files
        const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${defaultBranch}?recursive=1`;
        console.log(`Requesting complete file tree from: ${treeUrl}`);
        
        const treeResponse = await fetch(treeUrl, {
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (!treeResponse.ok) {
            throw new Error(`Failed to get repository file tree: ${treeResponse.status}`);
        }
        
        const treeData = await treeResponse.json();
        
        // Check if truncated (extremely large repos may still hit limits)
        if (treeData.truncated) {
            console.warn('Warning: Repository tree is truncated. Some files may not be listed.');
        }
        
        // Filter for the requested path and convert to the format expected by the rest of the code
        let filteredItems = [];
        
        // Clean up path to ensure consistent matching
        const normalizedPath = path.replace(/^\/|\/$/g, '');
        const pathPrefix = normalizedPath ? `${normalizedPath}/` : '';
        
        treeData.tree.forEach(item => {
            // Only include blobs (files)
            if (item.type !== 'blob') return;
            
            // Check if the item is in the requested path
            if (normalizedPath) {
                // If path specified, include only files directly in that path (not subdirectories)
                const itemPath = item.path;
                const pathParts = itemPath.split('/');
                const itemDirectory = pathParts.slice(0, -1).join('/');
                
                if (itemDirectory !== normalizedPath) return;
            } else {
                // If no path specified (root), only include files directly in root
                if (item.path.includes('/')) return;
            }
            
            // Convert to the format expected by existing code
            filteredItems.push({
                name: item.path.split('/').pop(),
                path: item.path,
                sha: item.sha,
                size: item.size,
                type: 'file',
                url: item.url
            });
        });
        
        if (filteredItems.length === 0 && normalizedPath) {
            // Path doesn't exist in repository
            if (createFolderIfMissing && createFolderIfMissing.checked) {
                console.log(`Path ${normalizedPath} not found but will be created during upload.`);
                return []; // Return empty array to indicate no existing files
            } else {
                throw new Error(`Path "${normalizedPath}" not found in repository. Enable "Create folder if missing" or verify path.`);
            }
        }
        
        return filteredItems;
    } catch (error) {
        console.error('Error getting repository content:', error);
        throw error;
    }
}

// Extract number from filename
function extractNumberFromFilename(filename, prefix) {
    // Make sure prefix is properly escaped for regex
    const escapedPrefix = prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`^${escapedPrefix}(\\d+)(?:_fullRes)?\\.(png|jpg)$`);
    const match = filename.match(regex);
    return match ? parseInt(match[1]) : null;
}

// Find the highest number in filenames
function findHighestNumber(files, prefix) {
    let highestNumber = 0;
    
    console.log(`Finding highest number with prefix '${prefix}' among ${files.length} files...`);
    
    // For debugging, log some sample filenames (up to 5)
    const sampleFiles = files.slice(0, 5).map(f => f.name);
    console.log(`Sample filenames: ${sampleFiles.join(', ')}${files.length > 5 ? '...' : ''}`);
    
    files.forEach(file => {
        if (!file.name) return;
        const number = extractNumberFromFilename(file.name, prefix);
        if (number && number > highestNumber) {
            highestNumber = number;
            console.log(`New highest: ${number} from file ${file.name}`);
        }
    });
    
    console.log(`Highest number found: ${highestNumber}`);
    return highestNumber;
}

// Check if a path exists in the repository
async function checkIfPathExists(owner, repo, token, path) {
    try {
        const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        return response.status === 200;
    } catch (error) {
        console.error('Error checking if path exists:', error);
        return false;
    }
}

// Check last uploaded files - fixed implementation
async function checkLastFiles() {
    if (!githubToken.value) {
        alert('Please enter GitHub token');
        return;
    }
    
    if (!repo.value.includes('/')) {
        alert('Repository format must be "username/repository-name"');
        return;
    }
    
    const prefix = fileNamePrefix.value || 'WDG';
    const path = uploadPath.value.trim();
    
    // Show loading indicator
    lastFilesContent.innerHTML = '<div class="loading-indicator"><span class="refresh-spinner"></span>Fetching latest files...</div>';
    
    try {
        // Parse repository information
        let [owner, repoName] = repo.value.split('/');
        
        // Remove trailing slash if present
        owner = owner.replace(/\/$/, '');
        
        if (!owner || !repoName) {
            throw new Error('Invalid repository format. Please use "username/repository-name"');
        }
        
        // Get repository content from specified path - using the improved function
        let files = [];
        try {
            files = await getRepositoryContent(owner, repoName, githubToken.value, path);
        } catch (error) {
            if (error.message.includes('not found') && createFolderIfMissing.checked) {
                // Path doesn't exist but will be created - show message
                lastFilesContent.innerHTML = `<p>The path "${path}" doesn't exist in the repository but will be created during upload.</p>`;
                return;
            } else {
                throw error; // Re-throw for other errors
            }
        }
        
        // Filter for files (not directories)
        files = Array.isArray(files) ? files.filter(file => file.type === 'file') : [];
        
        // Sort files by name
        files.sort((a, b) => a.name.localeCompare(b.name));
        
        // Find the highest number
        const highestNumber = findHighestNumber(files, prefix);
        
        // Update the start number
        if (highestNumber > 0) {
            startNumber.value = highestNumber + 1;
            updateFilenamePreview();
        }
        
        // Show last files
        const lastFiles = files
            .filter(file => extractNumberFromFilename(file.name, prefix) !== null)
            .sort((a, b) => {
                // Sort by number descending to show highest numbers first
                const numA = extractNumberFromFilename(a.name, prefix);
                const numB = extractNumberFromFilename(b.name, prefix);
                return numB - numA;
            })
            .slice(0, 10); // Take top 10 after sorting
        
        if (lastFiles.length === 0) {
            lastFilesContent.innerHTML = `<p>No files found with prefix "${prefix}" in the ${path || 'root'} folder.</p>`;
            return;
        }
        
        let html = '<div>';
        
        // Group files by number
        const fileGroups = {};
        
        lastFiles.forEach(file => {
            const number = extractNumberFromFilename(file.name, prefix);
            if (!fileGroups[number]) {
                fileGroups[number] = [];
            }
            fileGroups[number].push(file);
        });
        
        // Sort groups by number (descending)
        const sortedNumbers = Object.keys(fileGroups).sort((a, b) => b - a);
        
        sortedNumbers.forEach(number => {
            const files = fileGroups[number];
            
            html += `<div class="last-file-item">
                <strong>${prefix}${number}</strong>: `;
            
            const fileNames = files.map(file => file.name).join(', ');
            html += fileNames;
            
            html += '</div>';
        });
        
        html += `<p><strong>Next number set to: ${highestNumber + 1}</strong></p>`;
        html += '</div>';
        
        lastFilesContent.innerHTML = html;
        
    } catch (error) {
        console.error('Failed to check last files:', error);
        lastFilesContent.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}

// Get the default branch and latest commit SHA
async function getLatestCommitSha(owner, repo, token) {
    try {
        // Get repository info
        const repoInfoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (!repoInfoResponse.ok) {
            if (repoInfoResponse.status === 404) {
                throw new Error(`Repository "${owner}/${repo}" not found. Please check the repository name.`);
            } else if (repoInfoResponse.status === 401) {
                throw new Error(`Authentication failed. Please check your GitHub token.`);
            } else {
                const errorData = await repoInfoResponse.json().catch(() => ({}));
                throw new Error(`GitHub API error (${repoInfoResponse.status}): ${errorData.message || repoInfoResponse.statusText}`);
            }
        }
        
        const repoInfo = await repoInfoResponse.json();
        const defaultBranch = repoInfo.default_branch;
        
        // Get reference for default branch
        const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${defaultBranch}`, {
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (!refResponse.ok) {
            throw new Error(`Failed to get reference for ${defaultBranch} branch: ${refResponse.status}`);
        }
        
        const refData = await refResponse.json();
        return {
            sha: refData.object.sha,
            branch: defaultBranch
        };
        
    } catch (error) {
        console.error('Error getting commit SHA:', error);
        throw error;
    }
}

// Check if folder exists and create it if needed
async function ensureFolderExists(owner, repo, token, path, baseCommitSha, defaultBranch) {
    if (!path || path === '') return baseCommitSha; // No folder needed
    
    try {
        // Check if folder exists
        const exists = await checkIfPathExists(owner, repo, token, path);
        if (exists) return baseCommitSha; // Folder already exists
        
        // Create folder by creating an empty file
        const placeholderContent = "# This folder contains uploaded images";
        const placeholderBlob = new Blob([placeholderContent], { type: 'text/plain' });
        const placeholderBase64 = await readBlobAsBase64(placeholderBlob);
        
        // Create blob for README.md
        const blobResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/blobs`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: placeholderBase64,
                encoding: 'base64'
            })
        });
        
        if (!blobResponse.ok) {
            throw new Error(`Failed to create blob: ${blobResponse.status}`);
        }
        
        const blobResult = await blobResponse.json();
        const blobSha = blobResult.sha;
        
        // Create tree with the folder and file
        const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                base_tree: baseCommitSha,
                tree: [{
                    path: `${path}/README.md`,
                    mode: '100644',
                    type: 'blob',
                    sha: blobSha
                }]
            })
        });
        
        if (!treeResponse.ok) {
            throw new Error(`Failed to create tree: ${treeResponse.status}`);
        }
        
        const treeResult = await treeResponse.json();
        const treeSha = treeResult.sha;
        
        // Create commit
        const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `Create ${path} folder`,
                tree: treeSha,
                parents: [baseCommitSha]
            })
        });
        
        if (!commitResponse.ok) {
            throw new Error(`Failed to create commit: ${commitResponse.status}`);
        }
        
        const commitResult = await commitResponse.json();
        const newCommitSha = commitResult.sha;
        
        // Update reference
        const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${defaultBranch}`, {
            method: 'PATCH',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                sha: newCommitSha,
                force: true
            })
        });
        
        if (!refResponse.ok) {
            throw new Error(`Failed to update ref: ${refResponse.status}`);
        }
        
        return newCommitSha;
    } catch (error) {
        console.error('Error ensuring folder exists:', error);
        throw error;
    }
}

// Upload a file to GitHub
async function uploadToGitHub(owner, repo, token, path, blob, baseCommitSha, defaultBranch, message) {
    try {
        // Create blob
        const blobData = await readBlobAsBase64(blob);
        const blobResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/blobs`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: blobData,
                encoding: 'base64'
            })
        });
        
        if (!blobResponse.ok) {
            throw new Error(`Failed to create blob: ${blobResponse.status}`);
        }
        
        const blobResult = await blobResponse.json();
        const blobSha = blobResult.sha;
        
        // Create tree
        const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                base_tree: baseCommitSha,
                tree: [{
                    path: path,
                    mode: '100644',
                    type: 'blob',
                    sha: blobSha
                }]
            })
        });
        
        if (!treeResponse.ok) {
            throw new Error(`Failed to create tree: ${treeResponse.status}`);
        }
        
        const treeResult = await treeResponse.json();
        const treeSha = treeResult.sha;
        
        // Create commit
        const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message,
                tree: treeSha,
                parents: [baseCommitSha]
            })
        });
        
        if (!commitResponse.ok) {
            throw new Error(`Failed to create commit: ${commitResponse.status}`);
        }
        
        const commitResult = await commitResponse.json();
        const newCommitSha = commitResult.sha;
        
        // Update reference
        const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${defaultBranch}`, {
            method: 'PATCH',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                sha: newCommitSha,
                force: true
            })
        });
        
        if (!refResponse.ok) {
            throw new Error(`Failed to update ref: ${refResponse.status}`);
        }
        
        return newCommitSha;
    } catch (error) {
        console.error('GitHub upload error:', error);
        throw error;
    }
}

// Improved delete function for GitHub files
async function deleteFromGitHub(owner, repo, token, path, sha, baseCommitSha, defaultBranch, message) {
    try {
        // The simpler way to delete a file is to use the contents API directly
        const deleteResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
            method: 'DELETE',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message,
                sha: sha,
                branch: defaultBranch
            })
        });
        
        // Check if the deletion was successful
        if (!deleteResponse.ok) {
            const errorData = await deleteResponse.json().catch(() => ({}));
            throw new Error(`Failed to delete file: ${deleteResponse.status} - ${errorData.message || deleteResponse.statusText}`);
        }
        
        // Get the new SHA after deletion
        const { sha: newCommitSha } = await getLatestCommitSha(owner, repo, token);
        return newCommitSha;
    } catch (error) {
        console.error('GitHub delete error:', error);
        throw error;
    }
}

// Upload button click handler
uploadBtn.addEventListener('click', async function() {
    if (!githubToken.value) {
        alert('Please enter GitHub token');
        return;
    }
    
    if (!repo.value.includes('/')) {
        alert('Repository format must be "username/repository-name"');
        return;
    }
    
    const files = imageUpload.files;
    if (files.length === 0) {
        alert('Please select at least one image');
        return;
    }
    
    // Show progress
    progressContainer.style.display = 'block';
    progressFill.style.width = '0%';
    statusIcon.className = 'status-icon pending';
    statusText.textContent = 'Starting upload...';
    uploadDetails.innerHTML = '';
    
    try {
        // Parse repository information
        let [owner, repoName] = repo.value.split('/');
        
        // Remove trailing slash if present
        owner = owner.replace(/\/$/, '');
        
        if (!owner || !repoName) {
            throw new Error('Invalid repository format. Please use "username/repository-name"');
        }

        // Get upload path
let uploadFolder = uploadPath.value.trim();
// Remove leading/trailing slashes
uploadFolder = uploadFolder.replace(/^\/|\/$/g, '');

// Get latest commit SHA
updateStatus('Getting repository information...', 'pending', 5);
const { sha: commitSha, branch: defaultBranch } = await getLatestCommitSha(owner, repoName, githubToken.value);

// Create folder if it doesn't exist
let latestCommitSha = commitSha;
if (uploadFolder && createFolderIfMissing.checked) {
    updateStatus('Checking if folder exists...', 'pending', 10);
    latestCommitSha = await ensureFolderExists(owner, repoName, githubToken.value, uploadFolder, latestCommitSha, defaultBranch);
}

// Process each image
let currentNumber = parseInt(startNumber.value);
let processedCount = 0;

updateStatus('Processing images...', 'pending', 20);

// Create an array to hold all file operations
const treeItems = [];
const processedFiles = [];

// Process each file and prepare for batch upload
for (let i = 0; i < files.length; i++) {
    const file = files[i];
    if (!file.type.match('image.*')) continue;
    
    const prefix = fileNamePrefix.value || 'WDG';
    const imageName = `${prefix}${currentNumber}`;
    
    try {
        updateStatus(`Processing image ${i + 1} of ${files.length}...`, 'pending', 20 + ((i / files.length) * 30));
        
        // Convert to PNG
        const pngImage = await convertToPng(file);
        
        // Create low-res JPEG
        const jpegImage = await createLowResJpeg(file, 660, 1431, 0.6);
        
        // Prepare file paths
        const pngPath = uploadFolder ? `${uploadFolder}/${imageName}_fullRes.png` : `${imageName}_fullRes.png`;
        const jpgPath = uploadFolder ? `${uploadFolder}/${imageName}.jpg` : `${imageName}.jpg`;
        
        // Convert to base64
        const pngBase64 = await readBlobAsBase64(pngImage);
        const jpgBase64 = await readBlobAsBase64(jpegImage);
        
        // Create blob for PNG
        const pngBlobResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/blobs`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${githubToken.value}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: pngBase64,
                encoding: 'base64'
            })
        });
        
        if (!pngBlobResponse.ok) {
            throw new Error(`Failed to create PNG blob: ${pngBlobResponse.status}`);
        }
        
        const pngBlobResult = await pngBlobResponse.json();
        
        // Create blob for JPG
        const jpgBlobResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/blobs`, {
            method: 'POST',
            headers: {
                'Authorization': `token ${githubToken.value}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: jpgBase64,
                encoding: 'base64'
            })
        });
        
        if (!jpgBlobResponse.ok) {
            throw new Error(`Failed to create JPG blob: ${jpgBlobResponse.status}`);
        }
        
        const jpgBlobResult = await jpgBlobResponse.json();
        
        // Add to tree items
        treeItems.push({
            path: pngPath,
            mode: '100644',
            type: 'blob',
            sha: pngBlobResult.sha
        });
        
        treeItems.push({
            path: jpgPath,
            mode: '100644',
            type: 'blob',
            sha: jpgBlobResult.sha
        });
        
        processedFiles.push(pngPath, jpgPath);
        processedCount++;
        currentNumber++;
        
    } catch (error) {
        console.error(`Error processing image ${imageName}:`, error);
        addUploadDetail(`❌ Failed to process ${imageName}: ${error.message}`);
    }
}

if (treeItems.length === 0) {
    throw new Error('No valid images were processed.');
}

// Create a tree with all processed files
updateStatus('Creating file tree...', 'pending', 60);
const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/trees`, {
    method: 'POST',
    headers: {
        'Authorization': `token ${githubToken.value}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        base_tree: latestCommitSha,
        tree: treeItems
    })
});

if (!treeResponse.ok) {
    throw new Error(`Failed to create tree: ${treeResponse.status}`);
}

const treeResult = await treeResponse.json();
const treeSha = treeResult.sha;

// Create commit with all files
updateStatus('Creating commit...', 'pending', 80);
const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/commits`, {
    method: 'POST',
    headers: {
        'Authorization': `token ${githubToken.value}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        message: `Upload ${processedCount} images (${treeItems.length} files)`,
        tree: treeSha,
        parents: [latestCommitSha]
    })
});

if (!commitResponse.ok) {
    throw new Error(`Failed to create commit: ${commitResponse.status}`);
}

const commitResult = await commitResponse.json();
const newCommitSha = commitResult.sha;

// Update reference
updateStatus('Updating repository...', 'pending', 90);
const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/refs/heads/${defaultBranch}`, {
    method: 'PATCH',
    headers: {
        'Authorization': `token ${githubToken.value}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        sha: newCommitSha,
        force: true
    })
});

if (!refResponse.ok) {
    throw new Error(`Failed to update ref: ${refResponse.status}`);
}

// Add upload details
processedFiles.forEach(filePath => {
    addUploadDetail(`✓ Uploaded ${filePath}`);
});

updateStatus(`Successfully uploaded ${processedCount} images (${treeItems.length} files)!`, 'success', 100);

// Update start number for next upload
startNumber.value = currentNumber;
updateFilenamePreview();

// Refresh the last files list after successful upload
setTimeout(() => {
    checkLastFiles();
}, 1000);

} catch (error) {
    console.error('Upload failed:', error);
    updateStatus(`Error: ${error.message}`, 'error', 0);
}
});

// Gallery functionality
let selectedFiles = [];

// Open gallery modal
viewGalleryBtn.addEventListener('click', async function() {
    if (!githubToken.value) {
        alert('Please enter GitHub token');
        return;
    }
    
    if (!repo.value.includes('/')) {
        alert('Repository format must be "username/repository-name"');
        return;
    }
    
    // Reset selection
    selectedFiles = [];
    selectedCount.textContent = '0 images selected';
    deleteSelectedBtn.disabled = true;
    
    // Show modal
    galleryModal.style.display = 'block';
    galleryLoading.style.display = 'block';
    galleryContent.style.display = 'none';
    
    try {
        // Parse repository information
        let [owner, repoName] = repo.value.split('/');
        
        // Remove trailing slash if present
        owner = owner.replace(/\/$/, '');
        
        if (!owner || !repoName) {
            throw new Error('Invalid repository format. Please use "username/repository-name"');
        }
        
        // Get upload path
        let uploadFolder = uploadPath.value.trim();
        // Remove leading/trailing slashes
        uploadFolder = uploadFolder.replace(/^\/|\/$/g, '');
        
        // Get repository content
        const files = await getRepositoryContent(owner, repoName, githubToken.value, uploadFolder);

        // Filter for JPG image files only
        const imageFiles = files.filter(file => 
            file.name.match(/\.jpg$/i) && 
            !file.name.match(/README\.md$/i) &&
            !file.name.match(/_fullRes\.png$/i) // Exclude full resolution PNG files
        );

        // Create a map of all files for quick lookup when deleting
        const allFilesMap = {};
        files.forEach(file => {
            allFilesMap[file.path] = file;
        });

        // Sort the images by filename numbers in descending order (newest first)
        // Extract the number from filenames using the same function as before
        const prefix = fileNamePrefix.value || 'WDG';
        imageFiles.sort((a, b) => {
            const numA = extractNumberFromFilename(a.name, prefix);
            const numB = extractNumberFromFilename(b.name, prefix);
            
            // If both have valid numbers, sort by number (descending)
            if (numA !== null && numB !== null) {
                return numB - numA; // Descending order (newest first)
            }
            
            // If one has a valid number and the other doesn't, prioritize the one with a number
            if (numA !== null) return -1;
            if (numB !== null) return 1;
            
            // If neither has a valid number, sort alphabetically
            return a.name.localeCompare(b.name);
        });
        
        // Clear gallery
        galleryGrid.innerHTML = '';
        
        // Add JPG images to gallery
        imageFiles.forEach(file => {
            const item = document.createElement('div');
            item.className = 'gallery-item';
            
            const img = document.createElement('img');
            img.className = 'gallery-img';
            img.src = `https://raw.githubusercontent.com/${owner}/${repoName}/main/${file.path}`;
            img.alt = file.name;
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'gallery-checkbox';
            checkbox.dataset.path = file.path;
            
            // Make sure we store the correct SHA - this is critical for deletion
            checkbox.dataset.sha = file.sha;
            
            // Find the corresponding PNG file (if it exists)
            const baseName = file.name.replace(/\.jpg$/i, '');
            const pngFileName = `${baseName}_fullRes.png`;
            const pngPath = file.path.replace(/\.jpg$/i, '_fullRes.png');
            
            // Store the PNG file info if found
            if (allFilesMap[pngPath]) {
                checkbox.dataset.pngPath = pngPath;
                checkbox.dataset.pngSha = allFilesMap[pngPath].sha;
                checkbox.dataset.pngName = pngFileName;
            }
            
            checkbox.addEventListener('change', function() {
                if (this.checked) {
                    const fileInfo = {
                        path: this.dataset.path,
                        sha: this.dataset.sha,
                        name: file.name
                    };
                    
                    // If there's a matching PNG file, include it in the selection
                    if (this.dataset.pngPath) {
                        fileInfo.hasPng = true;
                        fileInfo.pngPath = this.dataset.pngPath;
                        fileInfo.pngSha = this.dataset.pngSha;
                        fileInfo.pngName = this.dataset.pngName;
                    }
                    
                    selectedFiles.push(fileInfo);
                    this.parentElement.classList.add('selected');
                } else {
                    selectedFiles = selectedFiles.filter(f => f.path !== this.dataset.path);
                    this.parentElement.classList.remove('selected');
                }
                
                selectedCount.textContent = `${selectedFiles.length} image${selectedFiles.length !== 1 ? 's' : ''} selected`;
                deleteSelectedBtn.disabled = selectedFiles.length === 0;
            });
            
            const filename = document.createElement('div');
            filename.className = 'gallery-filename';
            filename.textContent = file.name;
            
            item.appendChild(img);
            item.appendChild(checkbox);
            item.appendChild(filename);
            
            galleryGrid.appendChild(item);
        });
        
        // Show gallery content
        galleryLoading.style.display = 'none';
        galleryContent.style.display = 'block';
        
    } catch (error) {
        console.error('Failed to load gallery:', error);
        galleryLoading.innerHTML = `<p>Error: ${error.message}</p>`;
    }
});

// Close gallery modal
closeModal.addEventListener('click', function() {
    galleryModal.style.display = 'none';
});

// Close modal when clicking outside
window.addEventListener('click', function(event) {
    if (event.target === galleryModal) {
        galleryModal.style.display = 'none';
    }
});

// Delete selected files
deleteSelectedBtn.addEventListener('click', async function() {
    if (selectedFiles.length === 0) return;
    
    // Count total files (including PNGs)
    const totalFileCount = selectedFiles.reduce((count, file) => {
        return count + (file.hasPng ? 2 : 1);
    }, 0);
    
    if (!confirm(`Are you sure you want to delete ${selectedFiles.length} selected image${selectedFiles.length !== 1 ? 's' : ''} (${totalFileCount} total files including high-resolution PNG files)? This action cannot be undone.`)) {
        return;
    }
    
    try {
        // Parse repository information
        let [owner, repoName] = repo.value.split('/');
        
        // Remove trailing slash if present
        owner = owner.replace(/\/$/, '');
        
        if (!owner || !repoName) {
            throw new Error('Invalid repository format. Please use "username/repository-name"');
        }
        
        // Get latest commit SHA
        const { sha: commitSha, branch: defaultBranch } = await getLatestCommitSha(owner, repoName, githubToken.value);
        
        // Show loading state
        deleteSelectedBtn.disabled = true;
        deleteSelectedBtn.textContent = 'Deleting...';
        
        // Delete each selected file
        let deletedCount = 0;
        let latestCommitSha = commitSha;
        
        for (const file of selectedFiles) {
            try {
                // Delete the JPG file
                latestCommitSha = await deleteFromGitHub(
                    owner,
                    repoName,
                    githubToken.value,
                    file.path,
                    file.sha,
                    latestCommitSha,
                    defaultBranch,
                    `Delete ${file.name}`
                );
                deletedCount++;
                
                // If there's a matching PNG file, delete it too
                if (file.hasPng) {
                    latestCommitSha = await deleteFromGitHub(
                        owner,
                        repoName,
                        githubToken.value,
                        file.pngPath,
                        file.pngSha,
                        latestCommitSha,
                        defaultBranch,
                        `Delete ${file.pngName}`
                    );
                    deletedCount++;
                }
                
                // Remove from gallery UI
                const item = document.querySelector(`.gallery-checkbox[data-path="${file.path}"]`).parentElement;
                item.style.opacity = '0.5';
                item.style.pointerEvents = 'none';
            } catch (error) {
                console.error(`Failed to delete ${file.path}:`, error);
            }
        }
        
        // Update UI
        deleteSelectedBtn.textContent = `Deleted ${deletedCount} file${deletedCount !== 1 ? 's' : ''}`;
        setTimeout(() => {
            deleteSelectedBtn.textContent = 'Delete Selected';
            deleteSelectedBtn.disabled = false;
        }, 2000);
        
        // Clear selection
        selectedFiles = [];
        selectedCount.textContent = '0 images selected';
        
        // Refresh the last files list after deletion
        setTimeout(() => {
            checkLastFiles();
        }, 1000);
        
    } catch (error) {
        console.error('Delete operation failed:', error);
        alert(`Error: ${error.message}`);
        deleteSelectedBtn.disabled = false;
        deleteSelectedBtn.textContent = 'Delete Selected';
    }
});

// Add event listener for check last files button
checkLastFilesBtn.addEventListener('click', checkLastFiles);

// Try to check for last files on initial load if token and repo are available
document.addEventListener('DOMContentLoaded', function() {
    if (githubToken.value && repo.value && repo.value.includes('/')) {
        checkLastFiles();
    }
});
</script>
</body>
</html>
        
      